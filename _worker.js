import { connect } from 'cloudflare:sockets';export default {async fetch(r,e){const u=e.UUID||'d342d11e-d424-4583-b36e-524ab1f0afa4',p=e.PROXYIP||'';try{const w=r.headers.get('Upgrade')==='websocket';return w?handleWsRequest(r,u,p):handleHttpRequest(r,u)}catch(err){return new Response(err.toString())}}};const handleHttpRequest=(r,u)=>{const t=new URL(r.url).pathname;if(t==='/')return new Response(JSON.stringify(r.cf,null,4));if(t===`/${u}`)return new Response(getConfig(u,r.headers.get("Host")),{"Content-Type":"text/plain;charset=utf-8"});return new Response("Not found",{status:404})};const handleWsRequest=async(r,u,p)=>{const[clientSocket,serverSocket]=new WebSocketPair();serverSocket.accept();const earlyDataHeader=r.headers.get('sec-websocket-protocol')||'',readableStream=createWebSocketStream(serverSocket,earlyDataHeader);let remoteSocket={value:null},isDns=false,responseHeader=new Uint8Array(2);const writableStream=new WritableStream({async write(c){if(remoteSocket.value){await writeToRemote(remoteSocket.value,c);return}const {hasError,addressRemote,portRemote,rawDataIndex,vlessVersion,isUDP}=processWebSocketHeader(c,u);if(hasError)return;responseHeader[0]=vlessVersion[0],responseHeader[1]=0;const rawClientData=c.slice(rawDataIndex);isDns=isUDP&&portRemote===53,isDns?await handleUdpRequest(serverSocket,responseHeader,rawClientData):handleTcpRequest(remoteSocket,addressRemote,portRemote,rawClientData,serverSocket,responseHeader,p)}});readableStream.pipeTo(writableStream);return new Response(null,{status:101,webSocket:clientSocket})};const writeToRemote=async(s,c)=>{const w=s.writable.getWriter();await w.write(c),w.releaseLock()};const connectAndWrite=async(s,a,b,c)=>{if(!s.value||s.value.closed)s.value=await connect({hostname:a,port:b});await writeToRemote(s.value,c);return s.value};const handleTcpRequest=async(s,a,b,c,t,r,p)=>{const tryconnect=async(a,b)=>{try{return await forwardToData(await connectAndWrite(s,a,b,c),t,r)}catch(e){return false}};if(!await tryconnect(a,b))!await tryconnect(p,b)&&closeWebSocket(t)};const createWebSocketStream=(s,e)=>{const l=new Set(),r=new ReadableStream({start(c){const {earlyData,error}=base64ToBuffer(e);if(error)return c.error(error);earlyData&&c.enqueue(earlyData);const handleMessage=e=>c.enqueue(e.data),handleClose=()=>{c.close(),removeWebSocketListeners(s)},handleError=e=>{c.error(e),removeWebSocketListeners(s)};l.add({event:'message',handler:handleMessage}),l.add({event:'close',handler:handleClose}),l.add({event:'error',handler:handleError}),s.addEventListener('message',handleMessage),s.addEventListener('close',handleClose),s.addEventListener('error',handleError)},cancel(){removeWebSocketListeners(s),closeWebSocket(s)}}),removeWebSocketListeners=s=>{l.forEach(({event,handler})=>{s.removeEventListener(event,handler)}),l.clear()};return r};const processWebSocketHeader=(b,u)=>{const v=new DataView(b),i=stringify(new Uint8Array(b.slice(1,17)));if(i!==u)return{hasError:true};const optLength=v.getUint8(17),s=18+optLength,c=v.getUint8(s),isUDP=c===2;return{hasError:false,addressRemote:getAddressInfo(v,b,18+optLength+3).addressRemote,portRemote=v.getUint16(s+1),rawDataIndex:getAddressInfo(v,b,18+optLength+3).rawDataIndex,vlessVersion:new Uint8Array(b.slice(0,1)),isUDP}};const getAddressInfo=(v,b,s)=>{const t=v.getUint8(s),l=t===2?v.getUint8(s+1):(t===1?4:16),i=s+(t===2?2:1),a=t===1?Array.from(new Uint8Array(b,i,4)).join('.'):t===2?new TextDecoder().decode(new Uint8Array(b,i,l)):Array.from(new Uint8Array(b,i,16)).map(b=>b.toString(16).padStart(2,'0')).join(':');return{addressRemote:a,rawDataIndex:i+l}};const forwardToData=async(s,t,r)=>{if(t.readyState!==WebSocket.OPEN)return closeWebSocket(t);const CHUNK_SIZE=512*1024;let hasData=false;const wStream=new WritableStream({async write(c){hasData=true;const dataToSend=r?new Uint8Array(r.length+c.byteLength):c;if(r){dataToSend.set(r),dataToSend.set(new Uint8Array(c),r.length),r=null}for(let o=0;o<dataToSend.byteLength;o+=CHUNK_SIZE){const e=Math.min(o+CHUNK_SIZE,dataToSend.byteLength);t.send(dataToSend.slice(o,e))}}});try{await s.readable.pipeTo(wStream)}catch(e){closeWebSocket(t)}return hasData};const BASE64_REPLACE_REGEX=/[-_]/g,replaceBase64Chars=str=>str.replace(BASE64_REPLACE_REGEX,(m=>m==='+'?'+':'/')),base64ToBuffer=b=>{try{const d=atob(replaceBase64Chars(b)),u=Uint8Array.from(d,c=>c.charCodeAt(0));return{earlyData:u.buffer,error:null}}catch(e){return{error:e}}};const closeWebSocket=s=>{s.readyState===WebSocket.OPEN||s.readyState===WebSocket.CLOSING&&s.close()};const byteToHex=Array.from({length:256},(_,i)=>(i+256).toString(16).slice(1)),stringify=(a,o=0)=>{const s=[4,2,2,2,6];return s.map(len=>Array.from({length:len},()=>byteToHex[a[o++]]).join('')).join('-').toLowerCase()};const handleUdpRequest=async(s,r,c)=>{const d=new Map(),batchSize=5,cacheTime=5*60*60*1000;let index=0,batch=[];if(!c||c.byteLength===0)return;const udpPackets=new Uint8Array(new DataView(c.buffer).getUint16(0)),dnsFetch=async(chunks)=>{const domain=new TextDecoder().decode(chunks[0]),cachedEntry=dnsCache.get(domain),currentTime=Date.now();if(cachedEntry&&(currentTime-cachedEntry.timestamp)<cacheTime)return cachedEntry.data;try{const response=await fetch('https://dns.google/dns-query',{method:'POST',headers:{'Content-Type':'application/dns-message'},body:concatenateChunks(chunks)}),result=await response.arrayBuffer();return dnsCache.set(domain,{data:result,timestamp:currentTime}),result}catch(e){return null}};const processBatch=async(c)=>{const dnsResults=await Promise.all(batch.map(dnsFetch));dnsResults.forEach(dnsResult=>{if(dnsResult)index=processDnsResult(dnsResult,udpPackets,index)}),c.enqueue(udpPackets.slice(0,index)),index=0,batch=[]};const transformStream=new TransformStream({async transform(c,c){let offset=0;while(offset<c.byteLength){const udpPacketLength=new DataView(c.buffer,offset,2).getUint16(0);batch.push(c.slice(offset+2,offset+2+udpPacketLength)),batch.length>=batchSize&&await processBatch(c),offset+=2+udpPacketLength}});const writer=transformStream.writable.getWriter();await writer.write(c),writer.close();const finalMessage=await transformStream.readable.getReader().read();s.readyState===WebSocket.OPEN&&s.send(finalMessage.value.buffer)};const concatenateChunks=chunks=>{const totalLength=chunks.reduce((sum,chunk)=>sum+chunk.byteLength,0),result=new Uint8Array(totalLength);let offset=0;chunks.forEach(chunk=>{result.set(chunk,offset),offset+=chunk.byteLength});return result.buffer};const processDnsResult=(dnsResult,udpPackets,index)=>{const responseArray=new Uint8Array(dnsResult);let offset=0;while(offset<responseArray.byteLength){const responseLength=new DataView(responseArray.buffer,offset,2).getUint16(0);udpPackets.set(responseArray.subarray(offset,offset+responseLength),index),index+=responseLength,offset+=responseLength}return index};const getConfig=(u,h)=>`vless://${u}@${h}:8443?encryption=none&security=tls&sni=${h}&fp=randomized&type=ws&host=${h}&path=%2F%3Fed%3D2560#${h}`;
