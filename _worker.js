import { connect } from 'cloudflare:sockets'; let userID = 'd342d11e-d424-4583-b36e-524ab1f0afa4', proxyIP = '', cachedUserID; export default { async fetch(request, env, ctx) { try { userID = env.UUID || userID; proxyIP = env.PROXYIP || proxyIP; const upgradeHeader = request.headers.get('Upgrade'); if (!upgradeHeader || upgradeHeader !== 'websocket') { const url = new URL(request.url); switch (url.pathname) { case '/': return new Response(JSON.stringify(request.cf), { status: 200 }); case `/${userID}`: return new Response(getConfig(userID, request.headers.get('Host')), { status: 200, headers: { "Content-Type": "text/plain;charset=utf-8" } }); default: return new Response('Not found', { status: 404 }); } } else { return await resOverWSHandler(request); } } catch (err) { return new Response(err.toString()); } } }; async function resOverWSHandler(request) { const webSocketPair = new WebSocketPair(); const [client, webSocket] = Object.values(webSocketPair); webSocket.accept(); let address = '', earlyHeader = request.headers.get('sec-websocket-protocol') || '', readableWebStream = makeWebStream(webSocket, earlyHeader), remoteSocket = { value: null }, udpWrite = null, isDns = false; readableWebStream.pipeTo(new WritableStream({ async write(chunk) { if (isDns && udpWrite) return udpWrite(chunk); if (remoteSocket.value) { const writer = remoteSocket.value.writable.getWriter(); await writer.write(chunk); writer.releaseLock(); return; } const { hasError, portRemote = 443, addressRemote = '', rawDataIndex, resVersion = new Uint8Array([0, 0]), isUDP } = processResHeader(chunk, userID); address = addressRemote; if (hasError) return; if (isUDP && portRemote === 53) { isDns = true; } else if (isUDP) { return; } const resHeader = new Uint8Array([resVersion[0], 0]), clientData = chunk.slice(rawDataIndex); if (isDns) { const { write } = await handleUDPOutBound(webSocket, resHeader); udpWrite = write; udpWrite(clientData); return; } handleTCPOutBound(remoteSocket, addressRemote, portRemote, clientData, webSocket, resHeader); } })).catch(() => closeWebSocket(webSocket)); return new Response(null, { status: 101, webSocket: client }); } async function handleTCPOutBound(remoteSocket, addressRemote, portRemote, clientData, webSocket, resHeader) { async function connectAndWrite(address, port) { if (!remoteSocket.value || remoteSocket.value.closed) remoteSocket.value = connect({ hostname: address, port: port }); const writer = remoteSocket.value.writable.getWriter(); await writer.write(clientData); writer.releaseLock(); return remoteSocket.value; } async function tryConnect(address, port) { const tcpSocket = await connectAndWrite(address, port); return forwardToData(tcpSocket, webSocket, resHeader); } if (!await tryConnect(addressRemote, portRemote)) { if (!await tryConnect(proxyIP, portRemote)) closeWebSocket(webSocket); } } function makeWebStream(webSocket, earlyHeader) { let isCancel = false; const stream = new ReadableStream({ start(controller) { webSocket.addEventListener('message', e => { if (isCancel) return; controller.enqueue(e.data); }); webSocket.addEventListener('close', () => { closeWebSocket(webSocket); if (!isCancel) controller.close(); }); webSocket.addEventListener('error', err => controller.error(err)); const { earlyData, error } = base64ToBuffer(earlyHeader); if (error) controller.error(error); else if (earlyData) controller.enqueue(earlyData); }, cancel() { if (!isCancel) { isCancel = true; closeWebSocket(webSocket); } } }); return stream; } function processResHeader(resBuffer, userID) { if (resBuffer.byteLength < 24) return { hasError: true }; const version = new Uint8Array(resBuffer.slice(0, 1)), bufferUserID = new Uint8Array(resBuffer.slice(1, 17)); cachedUserID = cachedUserID || new Uint8Array(userID.replace(/-/g, '').match(/../g).map(b => parseInt(b, 16))); if (bufferUserID.some((byte, i) => byte !== cachedUserID[i])) return { hasError: true }; const optLength = new Uint8Array(resBuffer.slice(17, 18))[0], command = new Uint8Array(resBuffer.slice(18 + optLength, 18 + optLength + 1))[0]; if (command !== 1 && command !== 2) return { hasError: true }; const isUDP = command === 2, portIndex = 18 + optLength + 1, portRemote = new DataView(resBuffer.slice(portIndex, portIndex + 2)).getUint16(0), addressIndex = portIndex + 2, addressType = new Uint8Array(resBuffer.slice(addressIndex, addressIndex + 1))[0]; let addressLength = 0, addressValueIndex = addressIndex + 1, addressValue = ''; switch (addressType) { case 1: addressLength = 4; addressValue = new Uint8Array(resBuffer.slice(addressValueIndex, addressValueIndex + addressLength)).join('.'); break; case 2: addressLength = new Uint8Array(resBuffer.slice(addressValueIndex, addressValueIndex + 1))[0]; addressValue = new TextDecoder().decode(resBuffer.slice(addressValueIndex + 1, addressValueIndex + 1 + addressLength)); break; case 3: addressLength = 16; addressValue = Array.from(new Uint16Array(resBuffer.slice(addressValueIndex, addressValueIndex + addressLength).buffer)).map(n => n.toString(16)).join(':'); break; default: return { hasError: true }; } return { hasError: false, addressRemote: addressValue, portRemote, rawDataIndex: addressValueIndex + addressLength, resVersion: version, isUDP }; } async function forwardToData(remoteSocket, webSocket, resHeader) { let hasData = false; await remoteSocket.readable.pipeTo(new WritableStream({ async write(chunk) { if (webSocket.readyState !== WebSocket.OPEN) return; const bufferToSend = resHeader ? new Uint8Array(resHeader.byteLength + chunk.byteLength).set(resHeader).set(chunk, resHeader.byteLength) : chunk; webSocket.send(bufferToSend); hasData = true; resHeader = null; } })).catch(() => closeWebSocket(webSocket)); return hasData; } function base64ToBuffer(base64Str) { try { if (!base64Str) return {}; const binaryStr = atob(base64Str.replace(/-/g, '+').replace(/_/g, '/')); return { earlyData: Uint8Array.from(binaryStr, c => c.charCodeAt(0)).buffer }; } catch (err) { return { error: err }; } } function closeWebSocket(socket) { if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CLOSING) socket.close(); } async function handleUDPOutBound(webSocket, resHeader) { let headerSent = false; const writer = new WritableStream({ async write(chunk) { try { const dnsResponse = await fetch('https://cloudflare-dns.com/dns-query', { method: 'POST', headers: { 'Content-Type': 'application/dns-message' }, body: chunk }).then(res => res.arrayBuffer()); if (dnsResponse && webSocket.readyState === WebSocket.OPEN) { const sizeBuffer = new Uint8Array([(dnsResponse.byteLength >> 8) & 0xff, dnsResponse.byteLength & 0xff]), resPayload = headerSent ? new Uint8Array(sizeBuffer.byteLength + dnsResponse.byteLength).set(sizeBuffer).set(new Uint8Array(dnsResponse), sizeBuffer.byteLength) : new Uint8Array(resHeader.byteLength + sizeBuffer.byteLength + dnsResponse.byteLength).set(resHeader).set(sizeBuffer, resHeader.byteLength).set(new Uint8Array(dnsResponse), resHeader.byteLength + sizeBuffer.byteLength); webSocket.send(resPayload); headerSent = true; } } catch { closeWebSocket(webSocket); } } }).getWriter(); return { write: chunk => writer.write(chunk).catch(() => {}) }; } function getConfig(userID, hostName) { return `vless://${userID}@${hostName}:443?encryption=none&security=tls&sni=${hostName}&fp=randomized&type=ws&host=${hostName}&path=%2F%3Fed%3D2560#${hostName}`; }
