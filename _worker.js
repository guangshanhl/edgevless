import { connect } from 'cloudflare:sockets'; export default { async fetch(request, env) { try { const userID = env.UUID ?? 'd342d11e-d424-4583-b36e-524ab1f0afa4', proxyIP = env.PROXYIP ?? ''; return request.headers.get('Upgrade') === 'websocket' ? handleWsRequest(request, userID, proxyIP) : handleHttpRequest(request, userID); } catch (err) { return new Response(err.toString()); } } }; const handleHttpRequest = (request, userID) => { const path = new URL(request.url).pathname, host = request.headers.get('Host'); if (path === '/') return new Response(JSON.stringify(request.cf, null, 4)); if (path === `/${userID}`) return new Response(getConfig(userID, host), { headers: { 'Content-Type': 'text/plain;charset=utf-8' } }); return new Response('Not found', { status: 404 }); }; const handleWsRequest = async (request, userID, proxyIP) => { const [client, webSocket] = new WebSocketPair(); webSocket.accept(); const earlyHeader = request.headers.get('sec-websocket-protocol') || '', readableStream = createSocketStream(webSocket, earlyHeader); let remoteSocket = { value: null }, udpWrite = null, isDns = !1, responseHeader = new Uint8Array(2); const processChunk = async chunk => { if (isDns && udpWrite) return udpWrite(chunk); if (remoteSocket.value) return await writeToRemote(remoteSocket.value, chunk); const { hasError, addressRemote, portRemote, rawDataIndex, Version, isUDP } = processSocketHeader(chunk, userID); if (hasError) return; responseHeader[0] = Version[0], responseHeader[1] = 0; const rawClientData = chunk.slice(rawDataIndex); isUDP ? (isDns = 53 === portRemote, udpWrite = isDns ? await handleUdpRequest(webSocket, responseHeader, rawClientData) : null) : handleTcpRequest(remoteSocket, addressRemote, portRemote, rawClientData, webSocket, responseHeader, proxyIP); }; readableStream.pipeTo(new WritableStream({ write: processChunk })); return new Response(null, { status: 101, webSocket: client }); }; const writeToRemote = async (socket, chunk) => { const writer = socket.writable.getWriter(); await writer.write(chunk), writer.releaseLock(); }; const handleTcpRequest = async (remoteSocket, addressRemote, portRemote, rawClientData, webSocket, responseHeader, proxyIP) => { try { const tcpSocket = await connectAndWrite(remoteSocket, addressRemote, portRemote, rawClientData); await forwardToData(tcpSocket, webSocket, responseHeader, async () => { const fallbackSocket = await connectAndWrite(remoteSocket, proxyIP || addressRemote, portRemote, rawClientData); fallbackSocket.closed.catch(() => {}).finally(() => closeWebSocket(webSocket)), await forwardToData(fallbackSocket, webSocket, responseHeader); }); } catch { closeWebSocket(webSocket); } }; const connectAndWrite = async (remoteSocket, address, port, rawClientData) => { remoteSocket.value && !remoteSocket.value.closed || (remoteSocket.value = await connect({ hostname: address, port })), await writeToRemote(remoteSocket.value, rawClientData); return remoteSocket.value; }; let reuseStream; const createSocketStream = (webSocket, earlyHeader) => { reuseStream && (reuseStream.cancel(), reuseStream = null); const { earlyData, error } = base64ToBuffer(earlyHeader); return error ? new ReadableStream().cancel() : (reuseStream = new ReadableStream({ start(controller) { earlyData && controller.enqueue(earlyData), webSocket.addEventListener('message', event => controller.enqueue(event.data)), webSocket.addEventListener('close', () => controller.close()), webSocket.addEventListener('error', err => controller.error(err)); }, cancel: () => closeWebSocket(webSocket) }), reuseStream); }; const processSocketHeader = (buffer, userID) => { const view = new DataView(buffer); if (stringify(new Uint8Array(buffer.slice(1, 17))) !== userID) return { hasError: !0 }; const optLength = view.getUint8(17), command = view.getUint8(18 + optLength), isUDP = 2 === command, portRemote = view.getUint16(18 + optLength + 1), addressIndex = 18 + optLength + 3, addressType = view.getUint8(addressIndex), addressLength = 2 === addressType ? view.getUint8(addressIndex + 1) : 1 === addressType ? 4 : 16, addressValueIndex = addressIndex + (2 === addressType ? 2 : 1); return { hasError: !1, addressRemote: 1 === addressType ? Array.from(new Uint8Array(buffer, addressValueIndex, 4)).join('.') : 2 === addressType ? new TextDecoder().decode(new Uint8Array(buffer, addressValueIndex, addressLength)) : Array.from(new Uint8Array(buffer, addressValueIndex, 16)).map(b => b.toString(16).padStart(2, '0')).join(':'), portRemote, rawDataIndex: addressValueIndex + addressLength, Version: [0], isUDP }; }; const forwardToData = async (remoteSocket, webSocket, responseHeader, retry) => { if (webSocket.readyState !== WebSocket.OPEN) return closeWebSocket(webSocket); let hasData = !1; const writable = new WritableStream({ write: async chunk => { hasData = !0; const combinedData = responseHeader ? new Uint8Array([...responseHeader, ...chunk]) : chunk; responseHeader = null, webSocket.send(combinedData); } }); try { await remoteSocket.readable.pipeTo(writable); } catch (error) { closeWebSocket(webSocket); } retry && !hasData && retry(); }; const base64ToBuffer = base64Str => { try { const formattedStr = base64Str.replace(/[-_]/g, m => '-' === m ? '+' : '/'), binaryStr = atob(formattedStr), buffer = Uint8Array.from(binaryStr, char => char.charCodeAt(0)); return { earlyData: buffer.buffer, error: null }; } catch (error) { return { earlyData: null, error }; } }; const closeWebSocket = webSocket => { [WebSocket.OPEN, WebSocket.CLOSING].includes(webSocket.readyState) && webSocket.close(); }; const byteToHex = Array.from({ length: 256 }, (_, i) => (i + 256).toString(16).slice(1)); const stringify = (arr, offset = 0) => [4, 2, 2, 2, 6].map(len => Array.from({ length: len }, () => byteToHex[arr[offset++]]).join('')).join('-').toLowerCase(); const handleUdpRequest = async (webSocket, responseHeader, rawClientData) => { const dataView = new DataView(rawClientData.buffer), dnsQueryBatches = Array.from({ length: rawClientData.byteLength }, (_, index) => { const udpPacketLength = dataView.getUint16(index), dnsQuery = rawClientData.slice(index + 2, index + 2 + udpPacketLength); return index += 2 + udpPacketLength, dnsQuery; }), dnsResponses = await Promise.all(dnsQueryBatches.map(dnsQuery => fetch('https://cloudflare-dns.com/dns-query', { method: 'POST', headers: { 'Content-Type': 'application/dns-message' }, body: dnsQuery }).then(response => response.arrayBuffer()).catch(() => null))); dnsResponses.forEach(dnsResult => { if (webSocket.readyState === WebSocket.OPEN) { const combinedData = new Uint8Array(responseHeader.length + 2 + dnsResult.byteLength); combinedData.set(responseHeader, 0), combinedData.set([dnsResult.byteLength >> 8, dnsResult.byteLength & 0xff], responseHeader.length), combinedData.set(new Uint8Array(dnsResult), responseHeader.length + 2), webSocket.send(combinedData); } }); }; const getConfig = (userID, host) => `vless://${userID}@${host}:443?encryption=none&security=tls&sni=${host}&fp=randomized&type=ws&host=${host}&path=%2F%3Fed%3D2560#${host}`;
